{"version":3,"sources":["worker-bot.ts","DiskDisplay.tsx","Scores.tsx","MoveDisplay.tsx","OthelloBoard.tsx","App.tsx","update-vh.ts","index.tsx","../../packages/@othello/game/dist/game.js","../../packages/@othello/worker/dist/worker.js","../../packages/@othello/logic/dist/othello.js"],"names":["worker","WorkerClass","handleMessageOnce","messageType","handler","addEventListener","listener","data","type","payload","window","removeEventListener","postMessage","DiskDisplay","disk","index","log","children","previousDisk","value","ref","React","useRef","useEffect","current","usePrevious","diskRef","createRef","diskElement","undefined","lastMove","i","length","action","getLastMove","getCoordsAtIndex","x","y","args","lastX","lastY","delay","Math","max","abs","style","animationDelay","animationDuration","className","classNames","Disk","BLACK","WHITE","Scores","black","white","currentPlayer","winner","MoveDisplay","onClick","OthelloBoard","G","ctx","moves","playerID","showPositions","playerDisk","getCurrentPlayer","getWinner","board","getScore","gameover","Array","from","BOARD_TILES","_","getDiskAtIndex","canPlay","isLegalMoveForIndex","lastPlaced","turn","clickCell","OthelloClient","Client","debug","game","OthelloGame","multiplayer","Local","bots","1","iterations","playoutDepth","minThinkTime","thinkDelay","setOpt","promise","Promise","resolve","MCTSBot","getBot","App","updateVH","document","documentElement","setProperty","innerHeight","rootElement","getElementById","render","Object","defineProperty","exports","diskToPlayer","playerToDisk","logic_1","require","player","Error","String","setup","createBoard","initializeBoard","moveLimit","order","first","_G","_ctx","next","currPos","playOrderPos","nextPos","numPlayers","nextPlayer","playOrder","nextDisk","hasLegalMoves","clone","slice","playMoveAtIndex","applyMoves","endIf","isGameOver","draw","ai","enumerate","getLegalMoveIndexesForPlayer","map","move","addMethods","methods","module","w","Worker","name","__spreadArrays","this","s","il","arguments","r","k","a","j","jl","getCardinalPositionFromIndex","getCardinalPositionFromCoords","playMoveAtCoords","getLegalMoveCoordsForPlayer","isLegalMoveForCoords","getOpponent","getAllLines","getLine","getAllNeighboringCoords","getNeighboringCoords","isBoardFull","assertBoardLegal","isBoardLegal","toString","hasDiskAtIndex","hasDiskAtCoords","setDiskAtIndex","setDiskAtCoords","getDiskAtCoords","FIRST_MOVE","BOARD_LENGTH","BOARD_SIZE","pow","Uint8Array","floor","apply","fill","invert","diskBlack","diskWhite","result","deltaX","deltaY","isNotNull","item","filter","curX","curY","coords","push","lines","opponent","outer","_i","lines_1","line","inner","newBoard","lines_2","countBits","count","offset","score","scoreBlack","scoreWhite","_a","fromCharCode"],"mappings":"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","file":"static/js/main.a384d463.chunk.js","sourcesContent":["import { MCTSBot } from 'boardgame.io/ai';\n// eslint-disable-next-line import/no-webpack-loader-syntax\nimport WorkerClass from 'workerize-loader!@othello/worker';\nimport { GetBotOptions } from './bot';\n\nconst worker = new WorkerClass();\n\nconst handleMessageOnce = <T = any>(messageType: string, handler: (payload?: T) => void) => {\n  const listener = ({ data }: { data: { type: string, payload: T } }) => {\n    if (!data || !data.type) return;\n    const { type, payload } = data;\n    if (messageType !== type) return;\n    handler(payload);\n    window.removeEventListener('message', listener);\n  };\n  worker.addEventListener('message', listener);\n};\n\nconst postMessage = <T = any>(type: string, payload?: T) => {\n  worker.postMessage({\n    type,\n    payload,\n  });\n};\n\nexport const getBot = ({\n  iterations,\n  playoutDepth,\n  minThinkTime = 500,\n  thinkDelay = 0,\n}: GetBotOptions) => (\n  class extends MCTSBot {\n    constructor (...args: ConstructorParameters<typeof MCTSBot>) {\n      super(...args);\n      this.setOpt('iterations', iterations);\n      this.setOpt('playoutDepth', playoutDepth);\n      postMessage('INITIALIZE_BOT', {\n        iterations,\n        playoutDepth,\n        minThinkTime,\n        thinkDelay,\n      });\n    }\n\n    async play (...args: Parameters<MCTSBot['play']>) {\n      const promise = new Promise((resolve) => {\n        handleMessageOnce('PLAY_RESULT', resolve);\n      });\n      postMessage('PLAY', args);\n      return await promise as ReturnType<MCTSBot['play']>;\n    }\n  }\n);\n","import React from 'react';\nimport { Disk, getCoordsAtIndex } from '@othello/logic';\nimport classNames from 'classnames';\nimport { LogEntry } from 'boardgame.io';\nimport './DiskDisplay.css';\n\nexport interface Props {\n  disk: Disk;\n  index?: number;\n  log?: LogEntry[];\n}\n\nfunction usePrevious <T>(value: T): T | undefined {\n  const ref = React.useRef<T>();\n  React.useEffect(() => {\n    ref.current = value;\n  }, [value]);\n  return ref.current;\n}\n\nconst getLastMove = (log: LogEntry[]): LogEntry | undefined => {\n  for (let i = log.length - 1; i >= 0; i--) {\n    if (log[i].action.type === 'MAKE_MOVE') return log[i];\n  }\n}\n\nconst DISTANCE_DELAY = 50;\n\nconst DiskDisplay: React.FC<Props> = ({ disk, index, log, children }) => {\n  const previousDisk = usePrevious(disk);\n  const diskRef = React.createRef<HTMLDivElement>();\n  \n  React.useEffect(() => {\n    const diskElement = diskRef.current;\n    if (\n      index === undefined ||\n      log === undefined ||\n      previousDisk === undefined ||\n      previousDisk === disk ||\n      !diskElement\n    ) return;\n    const lastMove = getLastMove(log);\n    if (lastMove === undefined) return;\n    const [x, y] = getCoordsAtIndex(index);\n    const [lastX, lastY] = getCoordsAtIndex(lastMove.action.payload.args[0]);\n    const distance = Math.max(Math.abs(x - lastX), Math.abs(y - lastY));\n    const delay = distance * DISTANCE_DELAY;\n    diskElement.style.animationDelay = `${delay / 1000}s`;\n    diskElement.style.animationDuration = `0.5s`;\n    // diskElement.style.animationDelay = '0s';\n  }, [diskRef, disk, previousDisk, index, log]);\n\n  return (\n    <div ref={diskRef} className={classNames('DiskDisplay', {\n      'DiskDisplay--black': disk === Disk.BLACK,\n      'DiskDisplay--white': disk === Disk.WHITE,\n    })}>\n      {children}\n    </div>\n  );\n};\n\nexport default DiskDisplay;\n","import React from 'react';\nimport classNames from 'classnames';\nimport { Disk } from '@othello/logic';\nimport DiskDisplay from './DiskDisplay';\nimport './Scores.css';\n\nexport interface Props {\n  black: number;\n  white: number;\n  currentPlayer: Disk | null;\n  winner: Disk | null;\n}\n\nconst Scores: React.FC<Props> = ({ black, white, currentPlayer, winner }) => {\n  return (\n    <div className={classNames('Scores', winner !== null && 'Scores--game-over')}>\n      <div className={classNames('Scores-player', {\n        'Scores-player--current-player': currentPlayer === Disk.BLACK,\n        'Scores-player--winner': winner === Disk.BLACK,\n      })}>\n        <div className=\"Scores-player-disk\">\n          <DiskDisplay disk={Disk.BLACK} />\n        </div>\n        <div className=\"Scores-player-score\">\n          {black}\n        </div>\n      </div>\n      <div className={classNames('Scores-player', {\n        'Scores-player--current-player': currentPlayer === Disk.WHITE,\n        'Scores-player--winner': winner === Disk.WHITE,\n      })}>\n        <div className=\"Scores-player-disk\">\n          <DiskDisplay disk={Disk.WHITE} />\n        </div>\n        <div className=\"Scores-player-score\">\n          {white}\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default Scores;\n","import React from 'react';\nimport './MoveDisplay.css';\n\nexport interface Props {\n  onClick?: () => void;\n}\n\nconst MoveDisplay: React.FC<Props> = ({ onClick }) => (\n  <button\n    className=\"MoveDisplay\"\n    type=\"button\"\n    onClick={onClick}\n  />\n);\n\nexport default MoveDisplay;\n","import React from 'react';\nimport { BOARD_TILES, Disk, getDiskAtIndex, getScore, getWinner, isLegalMoveForIndex } from '@othello/logic';\nimport { G, getCurrentPlayer } from '@othello/game';\nimport { BoardProps } from 'boardgame.io/react';\nimport Scores from './Scores';\nimport DiskDisplay from './DiskDisplay';\nimport MoveDisplay from './MoveDisplay';\nimport './OthelloBoard.css';\n\nexport type Props = BoardProps<G>\n\nconst OthelloBoard: React.FC<Props> = ({ G, ctx, moves, playerID, log }) => {\n  const showPositions = (\n    // Player ID must be specified\n    playerID != null &&\n    // It's our turn\n    ctx.currentPlayer === playerID\n  );\n  const playerDisk = getCurrentPlayer(ctx);\n  const winner = getWinner(G.board);\n  const mapToTile = (_: unknown, i: number) => {\n    const disk = getDiskAtIndex(G.board, i);\n    const canPlay = showPositions && isLegalMoveForIndex(G.board, i, playerDisk);\n    return (\n      <div className=\"OthelloBoard-tile\" key={`tile-${i}`}>\n        {disk !== null && (\n          <DiskDisplay disk={disk} key={`disk-${i}`} index={i} log={log}>\n            {G.lastPlaced === i && <span>{ctx.turn - 1}</span>}\n          </DiskDisplay>\n        )}\n        {canPlay && (\n          <MoveDisplay onClick={() => moves.clickCell(i)} />\n        )}\n      </div>\n    );\n  };\n  return (\n    <div className=\"OthelloBoard\">\n      <Scores\n        black={getScore(G.board, Disk.BLACK)}\n        white={getScore(G.board, Disk.WHITE)}\n        currentPlayer={playerDisk}\n        winner={ctx.gameover ? winner : null}\n      />\n      <div className=\"OthelloBoard-square\">\n        <div className=\"OthelloBoard-grid\">\n          {Array.from(new Array(BOARD_TILES), mapToTile)}\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default OthelloBoard;\n","import React from 'react';\nimport { OthelloGame } from '@othello/game';\nimport { Local } from 'boardgame.io/multiplayer';\nimport { Client } from 'boardgame.io/react';\nimport { getBot } from './worker-bot';\nimport OthelloBoard from './OthelloBoard';\nimport './App.css';\n\nconst OthelloClient = Client({\n  debug: false,\n  game: OthelloGame,\n  board: OthelloBoard,\n  multiplayer: Local({\n    bots: {\n      1: getBot({\n        iterations: 500,\n        playoutDepth: 59,\n      }),\n    },\n  }),\n});\n\nconst App: React.FC = () => (\n  <div className=\"App\">\n    <OthelloClient playerID=\"0\" />\n  </div>\n);\n\nexport default App;\n","/** See https://css-tricks.com/the-trick-to-viewport-units-on-mobile/ */\nexport const updateVH = () => document.documentElement.style.setProperty('--vh', window.innerHeight * 0.01 + 'px');\n\nwindow.addEventListener('resize', updateVH);\n\nupdateVH();\n","import * as React from 'react';\nimport { render } from 'react-dom';\nimport App from './App';\nimport './update-vh';\nimport './styles.css';\n\nconst rootElement = document.getElementById(\"root\");\nrender(<App />, rootElement);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OthelloGame = exports.getCurrentPlayer = exports.diskToPlayer = exports.playerToDisk = void 0;\nvar logic_1 = require(\"@othello/logic\");\nvar playerToDisk = function (player) {\n    switch (player) {\n        case '0': return logic_1.Disk.BLACK;\n        case '1': return logic_1.Disk.WHITE;\n        default: throw new Error('Unexpected player ID: ' + player);\n    }\n};\nexports.playerToDisk = playerToDisk;\nvar diskToPlayer = function (disk) { return (String(disk)); };\nexports.diskToPlayer = diskToPlayer;\nvar getCurrentPlayer = function (ctx) { return (exports.playerToDisk(ctx.currentPlayer)); };\nexports.getCurrentPlayer = getCurrentPlayer;\nexports.OthelloGame = {\n    setup: function () {\n        var board = logic_1.createBoard();\n        logic_1.initializeBoard(board);\n        return {\n            board: board,\n            lastPlaced: null,\n        };\n    },\n    turn: {\n        moveLimit: 1,\n        order: {\n            first: function (_G, _ctx) { return 0; },\n            /**\n             * Called at the end of a player's turn.\n             * E.g. called after player 0 plays their first move and\n             * `ctx.playOrderPos` will be 0.\n             */\n            next: function (G, ctx) {\n                var currPos = ctx.playOrderPos;\n                var nextPos = (currPos + 1) % ctx.numPlayers;\n                var nextPlayer = ctx.playOrder[nextPos];\n                var nextDisk = exports.playerToDisk(nextPlayer);\n                return logic_1.hasLegalMoves(G.board, nextDisk) ? nextPos : currPos;\n            },\n        },\n    },\n    moves: {\n        clickCell: function (G, ctx, index) {\n            var board = G.board;\n            var disk = exports.getCurrentPlayer(ctx);\n            if (!logic_1.isLegalMoveForIndex(board, index, disk)) {\n                // TODO: Replace with `INVALID_MOVE` constant when not using Codesandbox\n                return 'INVALID_MOVE';\n            }\n            var clone = board.slice(0);\n            var moves = logic_1.playMoveAtIndex(clone, index, disk);\n            logic_1.applyMoves(clone, moves);\n            return {\n                board: clone,\n                lastPlaced: index,\n            };\n        },\n    },\n    endIf: function (G, _ctx) {\n        var board = G.board;\n        if (!logic_1.isGameOver(board))\n            return;\n        var winner = logic_1.getWinner(board);\n        if (winner === null)\n            return { draw: true };\n        return { winner: exports.diskToPlayer(winner) };\n    },\n    ai: {\n        enumerate: function (G, ctx) {\n            var board = G.board;\n            var disk = exports.getCurrentPlayer(ctx);\n            return logic_1.getLegalMoveIndexesForPlayer(board, disk)\n                .map(function (i) { return ({\n                move: 'clickCell',\n                args: [i],\n            }); });\n        },\n    },\n};\n","\n\t\t\t\tvar addMethods = require(\"../../../../node_modules/workerize-loader/dist/rpc-wrapper.js\")\n\t\t\t\tvar methods = []\n\t\t\t\tmodule.exports = function() {\n\t\t\t\t\tvar w = new Worker(__webpack_public_path__ + \"81c499fc988a691565d8.worker.js\", { name: \"[hash].worker.js\" })\n\t\t\t\t\taddMethods(w, methods)\n\t\t\t\t\t\n\t\t\t\t\treturn w\n\t\t\t\t}\n\t\t\t","\"use strict\";\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getCardinalPositionFromIndex = exports.getCardinalPositionFromCoords = exports.getWinner = exports.getScore = exports.isGameOver = exports.applyMoves = exports.playMoveAtIndex = exports.playMoveAtCoords = exports.getLegalMoveCoordsForPlayer = exports.hasLegalMoves = exports.getLegalMoveIndexesForPlayer = exports.isLegalMoveForIndex = exports.isLegalMoveForCoords = exports.getOpponent = exports.getAllLines = exports.getLine = exports.getAllNeighboringCoords = exports.getNeighboringCoords = exports.isBoardFull = exports.assertBoardLegal = exports.isBoardLegal = exports.toString = exports.initializeBoard = exports.hasDiskAtIndex = exports.hasDiskAtCoords = exports.setDiskAtIndex = exports.setDiskAtCoords = exports.getDiskAtIndex = exports.getDiskAtCoords = exports.getCoordsAtIndex = exports.createBoard = exports.FIRST_MOVE = exports.Disk = exports.BOARD_LENGTH = exports.BOARD_TILES = exports.BOARD_SIZE = void 0;\n/** Board has this many tiles wide vs tall */\nexports.BOARD_SIZE = 8;\n/** Total number of tiles on a board */\nexports.BOARD_TILES = Math.pow(exports.BOARD_SIZE, 2);\n/** Length of board array */\nexports.BOARD_LENGTH = exports.BOARD_SIZE * 2;\n/** Player disks are either dark (black) or light (white) */\nvar Disk;\n(function (Disk) {\n    Disk[Disk[\"BLACK\"] = 0] = \"BLACK\";\n    Disk[Disk[\"WHITE\"] = 1] = \"WHITE\";\n})(Disk = exports.Disk || (exports.Disk = {}));\n/** Dark disk player always moves first */\nexports.FIRST_MOVE = Disk.BLACK;\n/** Create a new board array */\nvar createBoard = function () { return (new Uint8Array(16)); };\nexports.createBoard = createBoard;\n/** Get the (x,y) coords for the given index */\nvar getCoordsAtIndex = function (index) { return [\n    index % 8,\n    Math.floor(index / 8)\n]; };\nexports.getCoordsAtIndex = getCoordsAtIndex;\n/** Determines which color disk is at these coords */\nvar getDiskAtCoords = function (board, x, y) {\n    if (board[y + 0] & (1 << x))\n        return Disk.BLACK;\n    if (board[y + 8] & (1 << x))\n        return Disk.WHITE;\n    return null;\n};\nexports.getDiskAtCoords = getDiskAtCoords;\n/** Determines which color disk is at this index */\nvar getDiskAtIndex = function (board, index) { return (exports.getDiskAtCoords.apply(void 0, __spreadArrays([board], exports.getCoordsAtIndex(index)))); };\nexports.getDiskAtIndex = getDiskAtIndex;\n/** Sets a single disk at the given coords */\nvar setDiskAtCoords = function (board, x, y, disk) {\n    board[y + 0] &= ~(1 << x);\n    board[y + 8] &= ~(1 << x);\n    if (disk === Disk.BLACK)\n        board[y + 0] |= 1 << x;\n    if (disk === Disk.WHITE)\n        board[y + 8] |= 1 << x;\n};\nexports.setDiskAtCoords = setDiskAtCoords;\n/** Sets a single disk at the given index */\nvar setDiskAtIndex = function (board, index, disk) { return (exports.setDiskAtCoords.apply(void 0, __spreadArrays([board], exports.getCoordsAtIndex(index), [disk]))); };\nexports.setDiskAtIndex = setDiskAtIndex;\n/** Is there a disk at the given coords? */\nvar hasDiskAtCoords = function (board, x, y) { return (exports.getDiskAtCoords(board, x, y) !== null); };\nexports.hasDiskAtCoords = hasDiskAtCoords;\n/** Is there a disk at the given index? */\nvar hasDiskAtIndex = function (board, index) { return (exports.getDiskAtCoords.apply(void 0, __spreadArrays([board], exports.getCoordsAtIndex(index))) !== null); };\nexports.hasDiskAtIndex = hasDiskAtIndex;\n/** Clear the entire board and place the four starting disks */\nvar initializeBoard = function (board) {\n    board.fill(0);\n    exports.setDiskAtCoords(board, 3, 3, Disk.WHITE); // White north west\n    exports.setDiskAtCoords(board, 4, 3, Disk.BLACK); // Black north east\n    exports.setDiskAtCoords(board, 3, 4, Disk.BLACK); // Black south west\n    exports.setDiskAtCoords(board, 4, 4, Disk.WHITE); // White south east\n};\nexports.initializeBoard = initializeBoard;\n/** Draw board as unicode string */\nvar toString = function (board, invert) {\n    if (invert === void 0) { invert = false; }\n    var diskBlack = invert ? '\\u25CB' : '\\u25CF';\n    var diskWhite = invert ? '\\u25CF' : '\\u25CB';\n    var result = '';\n    for (var y = 0; y < 8; y++) {\n        for (var x = 0; x < 8; x++) {\n            var disk = exports.getDiskAtCoords(board, x, y);\n            if (disk === Disk.BLACK) {\n                result += diskBlack;\n            }\n            else if (disk === Disk.WHITE) {\n                result += diskWhite;\n            }\n            else {\n                result += '\\xB7';\n            }\n        }\n        if (y < 7)\n            result += '\\n';\n    }\n    return result;\n};\nexports.toString = toString;\n/** Returns false if board is in an illegal state */\nvar isBoardLegal = function (board) {\n    for (var y = 0; y < 8; y++) {\n        if (board[y] & board[y + 8]) {\n            return false;\n        }\n    }\n    return true;\n};\nexports.isBoardLegal = isBoardLegal;\n/** Throws if board is in an illegal state */\nvar assertBoardLegal = function (board) {\n    if (!exports.isBoardLegal(board)) {\n        throw new Error('Board is in an illegal state');\n    }\n};\nexports.assertBoardLegal = assertBoardLegal;\n/** Returns true if every position on board is filled */\nvar isBoardFull = function (board) {\n    for (var y = 0; y < 8; y++) {\n        if (board[y] ^ board[y + 8] ^ 255) {\n            return false;\n        }\n    }\n    return true;\n};\nexports.isBoardFull = isBoardFull;\n/** Returns the coordinates in the given direction or null if on an edge */\nvar getNeighboringCoords = function (x, y, deltaX, deltaY) { return (x + deltaX < 0 ||\n    x + deltaX > 7 ||\n    y + deltaY < 0 ||\n    y + deltaY > 7 ?\n    null :\n    [x + deltaX, y + deltaY]); };\nexports.getNeighboringCoords = getNeighboringCoords;\n/** Type check input is not null */\nvar isNotNull = function (item) { return (item !== null); };\n/** Get coordinates for cells around all sides of given coords */\nvar getAllNeighboringCoords = function (x, y) { return [\n    exports.getNeighboringCoords(x, y, -1, -1),\n    exports.getNeighboringCoords(x, y, +0, -1),\n    exports.getNeighboringCoords(x, y, +1, -1),\n    exports.getNeighboringCoords(x, y, -1, +0),\n    exports.getNeighboringCoords(x, y, +1, +0),\n    exports.getNeighboringCoords(x, y, -1, +1),\n    exports.getNeighboringCoords(x, y, +0, +1),\n    exports.getNeighboringCoords(x, y, +1, +1),\n].filter(isNotNull); };\nexports.getAllNeighboringCoords = getAllNeighboringCoords;\n/** Get all valid coordinates in any direction from the given coords */\nvar getLine = function (x, y, deltaX, deltaY) {\n    var result = [];\n    var curX = x;\n    var curY = y;\n    while (true) {\n        var coords = exports.getNeighboringCoords(curX, curY, deltaX, deltaY);\n        if (!coords)\n            break;\n        result.push(coords);\n        curX += deltaX;\n        curY += deltaY;\n    }\n    return result;\n};\nexports.getLine = getLine;\n/** Get all lines in all directions from the given coords */\nvar getAllLines = function (x, y) { return [\n    exports.getLine(x, y, -1, -1),\n    exports.getLine(x, y, +0, -1),\n    exports.getLine(x, y, +1, -1),\n    exports.getLine(x, y, -1, +0),\n    exports.getLine(x, y, +1, +0),\n    exports.getLine(x, y, -1, +1),\n    exports.getLine(x, y, +0, +1),\n    exports.getLine(x, y, +1, +1),\n]; };\nexports.getAllLines = getAllLines;\n/** Get the opposing disk color */\nvar getOpponent = function (disk) { return (disk === Disk.BLACK ? Disk.WHITE : Disk.BLACK); };\nexports.getOpponent = getOpponent;\n/** Returns true if the postion at these coords can be played legally */\nvar isLegalMoveForCoords = function (board, x, y, disk) {\n    // Cannot play a disk in a position which already has a disk\n    if (exports.hasDiskAtCoords(board, x, y))\n        return false;\n    var lines = exports.getAllLines(x, y);\n    var opponent = exports.getOpponent(disk);\n    outer: for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {\n        var line = lines_1[_i];\n        // Must be at least two disks for a legal move\n        if (line.length < 2)\n            continue;\n        // First disk in line must be of the opposite color\n        if (exports.getDiskAtCoords(board, line[0][0], line[0][1]) !== opponent)\n            continue;\n        inner: for (var i = 1; i < line.length; i++) {\n            switch (exports.getDiskAtCoords(board, line[i][0], line[i][1])) {\n                // Valid move if there is a disk of our color in line\n                case disk: return true;\n                // Keep iterating over the their disks in this line\n                case opponent: continue inner;\n                // This move is not valid in this line if we hit an empty spot\n                default: continue outer;\n            }\n        }\n    }\n    // No valid moves found\n    return false;\n};\nexports.isLegalMoveForCoords = isLegalMoveForCoords;\n/** Returns true if the postion at this index can be played legally */\nvar isLegalMoveForIndex = function (board, index, disk) { return (exports.isLegalMoveForCoords.apply(void 0, __spreadArrays([board], exports.getCoordsAtIndex(index), [disk]))); };\nexports.isLegalMoveForIndex = isLegalMoveForIndex;\n/** Returns an array of all legal moves by index that the player can make */\nvar getLegalMoveIndexesForPlayer = function (board, disk) {\n    var moves = [];\n    for (var i = 0; i < exports.BOARD_TILES; i++) {\n        if (exports.isLegalMoveForIndex(board, i, disk)) {\n            moves.push(i);\n        }\n    }\n    return moves;\n};\nexports.getLegalMoveIndexesForPlayer = getLegalMoveIndexesForPlayer;\n/** Returns true if the player can make any moves at all */\nvar hasLegalMoves = function (board, disk) {\n    for (var i = 0; i < exports.BOARD_TILES; i++) {\n        if (exports.isLegalMoveForIndex(board, i, disk)) {\n            return true;\n        }\n    }\n    return false;\n};\nexports.hasLegalMoves = hasLegalMoves;\n/** Returns an array of all legal moves by coords that the player can make */\nvar getLegalMoveCoordsForPlayer = function (board, disk) {\n    var moves = [];\n    for (var y = 0; y < exports.BOARD_SIZE; y++) {\n        for (var x = 0; x < exports.BOARD_SIZE; x++) {\n            if (exports.isLegalMoveForIndex(board, x, disk)) {\n                moves.push([x, y]);\n            }\n        }\n    }\n    return moves;\n};\nexports.getLegalMoveCoordsForPlayer = getLegalMoveCoordsForPlayer;\n/** Returns a new board with the state of the board after this move is played */\nvar playMoveAtCoords = function (board, x, y, disk) {\n    var newBoard = exports.createBoard();\n    if (!exports.isLegalMoveForCoords(board, x, y, disk)) {\n        throw new Error('Move is illegal');\n    }\n    exports.setDiskAtCoords(newBoard, x, y, disk);\n    var lines = exports.getAllLines(x, y);\n    var opponent = exports.getOpponent(disk);\n    outer: for (var _i = 0, lines_2 = lines; _i < lines_2.length; _i++) {\n        var line = lines_2[_i];\n        // Must be at least two disks for a legal move\n        if (line.length < 2)\n            continue;\n        // First disk in line must be of the opposite color\n        if (exports.getDiskAtCoords(board, line[0][0], line[0][1]) !== opponent)\n            continue;\n        inner: for (var i = 1; i < line.length; i++) {\n            switch (exports.getDiskAtCoords(board, line[i][0], line[i][1])) {\n                // Valid move if there is a disk of our color in line\n                case disk: {\n                    for (var j = 0; j < i; j++) {\n                        exports.setDiskAtCoords(newBoard, line[j][0], line[j][1], disk);\n                    }\n                    continue outer;\n                }\n                // Keep iterating over the their disks in this line\n                case opponent: continue inner;\n                // This move is not valid in this line if we hit an empty spot\n                default: continue outer;\n            }\n        }\n    }\n    return newBoard;\n};\nexports.playMoveAtCoords = playMoveAtCoords;\n/** Returns a new board with the state of the board after this move is played */\nvar playMoveAtIndex = function (board, index, disk) { return (exports.playMoveAtCoords.apply(void 0, __spreadArrays([board], exports.getCoordsAtIndex(index), [disk]))); };\nexports.playMoveAtIndex = playMoveAtIndex;\n/** Takes a set of moves and applies them to a game board */\nvar applyMoves = function (board, moves) {\n    for (var y = 0; y < 8; y++) {\n        // Unset white moves from black positions\n        board[y + 0] &= ~moves[y + 8];\n        // Unset black moves from white positions\n        board[y + 8] &= ~moves[y + 0];\n        // Set black moves to black positions\n        board[y + 0] |= moves[y + 0];\n        // Set white moves to white positions\n        board[y + 8] |= moves[y + 8];\n    }\n};\nexports.applyMoves = applyMoves;\n/** Returns true if board is full or no more valid moves */\n// TODO: Add unit tests\nvar isGameOver = function (board) {\n    if (exports.isBoardFull(board))\n        return true;\n    for (var i = 0; i < exports.BOARD_TILES; i++) {\n        if (exports.isLegalMoveForIndex(board, i, Disk.BLACK) ||\n            exports.isLegalMoveForIndex(board, i, Disk.WHITE))\n            return false;\n    }\n    return true;\n};\nexports.isGameOver = isGameOver;\n/** Returns the number of set bits in an integer */\nvar countBits = function (value) {\n    var count = 0;\n    while (value > 0) {\n        if ((value & 1) === 1)\n            count++;\n        value >>= 1;\n    }\n    return count;\n};\n/** Get the number of disks of the given color on the board */\nvar getScore = function (board, disk) {\n    var offset = disk === Disk.BLACK ? 0 : 8;\n    var score = 0;\n    for (var i = 0; i < 8; i++) {\n        score += countBits(board[i + offset]);\n    }\n    return score;\n};\nexports.getScore = getScore;\n/** Return the color with the higher score or null if draw */\nvar getWinner = function (board) {\n    var scoreBlack = exports.getScore(board, Disk.BLACK);\n    var scoreWhite = exports.getScore(board, Disk.WHITE);\n    if (scoreBlack > scoreWhite)\n        return Disk.BLACK;\n    if (scoreWhite > scoreBlack)\n        return Disk.WHITE;\n    return null;\n};\nexports.getWinner = getWinner;\n/** Converts e.g. (5,4) to \"f5\" */\nvar getCardinalPositionFromCoords = function () {\n    var _a = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        _a[_i] = arguments[_i];\n    }\n    var x = _a[0], y = _a[1];\n    if (x < 0 || x > 7 || y < 0 || y > 7)\n        throw new Error('Position is out of bounds');\n    return String.fromCharCode(0x61 + x) + (y + 1);\n};\nexports.getCardinalPositionFromCoords = getCardinalPositionFromCoords;\n/** Converts e.g. 37 to \"f5\" */\nvar getCardinalPositionFromIndex = function (index) { return (exports.getCardinalPositionFromCoords.apply(void 0, exports.getCoordsAtIndex(index))); };\nexports.getCardinalPositionFromIndex = getCardinalPositionFromIndex;\n"],"sourceRoot":""}