{"version":3,"sources":["../../packages/@othello/logic/dist/othello.js","worker-bot.ts","DiskDisplay.tsx","MoveDisplay.tsx","OthelloBoard.tsx","App.tsx","update-vh.ts","index.tsx","../../packages/@othello/game/dist/game.js","../../packages/@othello/worker/dist/worker.js"],"names":["Disk","__spreadArrays","this","s","i","il","arguments","length","r","Array","k","a","j","jl","Object","defineProperty","exports","value","getCardinalPositionFromIndex","getCardinalPositionFromCoords","getWinner","getScore","isGameOver","applyMoves","playMoveAtIndex","playMoveAtCoords","getLegalMoveCoordsForPlayer","hasLegalMoves","getLegalMoveIndexesForPlayer","isLegalMoveForIndex","isLegalMoveForCoords","getOpponent","getAllLines","getLine","getAllNeighboringCoords","getNeighboringCoords","isBoardFull","assertBoardLegal","isBoardLegal","toString","initializeBoard","hasDiskAtIndex","hasDiskAtCoords","setDiskAtIndex","setDiskAtCoords","getDiskAtIndex","getDiskAtCoords","getCoordsAtIndex","createBoard","FIRST_MOVE","BOARD_LENGTH","BOARD_TILES","BOARD_SIZE","Math","pow","BLACK","Uint8Array","index","floor","board","x","y","WHITE","apply","disk","fill","invert","diskBlack","diskWhite","result","Error","deltaX","deltaY","isNotNull","item","filter","curX","curY","coords","push","lines","opponent","outer","_i","lines_1","line","inner","moves","newBoard","lines_2","countBits","count","offset","score","scoreBlack","scoreWhite","_a","String","fromCharCode","worker","WorkerClass","handleMessageOnce","messageType","handler","addEventListener","listener","data","type","payload","window","removeEventListener","postMessage","WorkerBot","args","promise","Promise","resolve","MCTSBot","DiskDisplay","log","children","previousDisk","ref","React","useRef","useEffect","current","usePrevious","diskRef","createRef","diskElement","undefined","lastMove","action","getLastMove","lastX","lastY","delay","max","abs","style","animationDelay","animationDuration","className","classNames","MoveDisplay","onClick","OthelloBoard","G","ctx","playerID","showPositions","currentPlayer","playerDisk","getCurrentPlayer","winner","from","_","canPlay","lastPlaced","turn","clickCell","gameover","OthelloClient","Client","debug","game","OthelloGame","multiplayer","Local","bots","1","App","updateVH","document","documentElement","setProperty","innerHeight","rootElement","getElementById","render","diskToPlayer","playerToDisk","logic_1","require","player","setup","moveLimit","order","first","_G","_ctx","next","currPos","playOrderPos","nextPos","numPlayers","nextPlayer","playOrder","nextDisk","clone","slice","endIf","draw","ai","enumerate","map","move","addMethods","methods","module","w","Worker","name"],"mappings":"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","file":"static/js/main.e42a28fd.chunk.js","sourcesContent":["\"use strict\";\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getCardinalPositionFromIndex = exports.getCardinalPositionFromCoords = exports.getWinner = exports.getScore = exports.isGameOver = exports.applyMoves = exports.playMoveAtIndex = exports.playMoveAtCoords = exports.getLegalMoveCoordsForPlayer = exports.hasLegalMoves = exports.getLegalMoveIndexesForPlayer = exports.isLegalMoveForIndex = exports.isLegalMoveForCoords = exports.getOpponent = exports.getAllLines = exports.getLine = exports.getAllNeighboringCoords = exports.getNeighboringCoords = exports.isBoardFull = exports.assertBoardLegal = exports.isBoardLegal = exports.toString = exports.initializeBoard = exports.hasDiskAtIndex = exports.hasDiskAtCoords = exports.setDiskAtIndex = exports.setDiskAtCoords = exports.getDiskAtIndex = exports.getDiskAtCoords = exports.getCoordsAtIndex = exports.createBoard = exports.FIRST_MOVE = exports.Disk = exports.BOARD_LENGTH = exports.BOARD_TILES = exports.BOARD_SIZE = void 0;\n/** Board has this many tiles wide vs tall */\nexports.BOARD_SIZE = 8;\n/** Total number of tiles on a board */\nexports.BOARD_TILES = Math.pow(exports.BOARD_SIZE, 2);\n/** Length of board array */\nexports.BOARD_LENGTH = exports.BOARD_SIZE * 2;\n/** Player disks are either dark (black) or light (white) */\nvar Disk;\n(function (Disk) {\n    Disk[Disk[\"BLACK\"] = 0] = \"BLACK\";\n    Disk[Disk[\"WHITE\"] = 1] = \"WHITE\";\n})(Disk = exports.Disk || (exports.Disk = {}));\n/** Dark disk player always moves first */\nexports.FIRST_MOVE = Disk.BLACK;\n/** Create a new board array */\nvar createBoard = function () { return (new Uint8Array(16)); };\nexports.createBoard = createBoard;\n/** Get the (x,y) coords for the given index */\nvar getCoordsAtIndex = function (index) { return [\n    index % 8,\n    Math.floor(index / 8)\n]; };\nexports.getCoordsAtIndex = getCoordsAtIndex;\n/** Determines which color disk is at these coords */\nvar getDiskAtCoords = function (board, x, y) {\n    if (board[y + 0] & (1 << x))\n        return Disk.BLACK;\n    if (board[y + 8] & (1 << x))\n        return Disk.WHITE;\n    return null;\n};\nexports.getDiskAtCoords = getDiskAtCoords;\n/** Determines which color disk is at this index */\nvar getDiskAtIndex = function (board, index) { return (exports.getDiskAtCoords.apply(void 0, __spreadArrays([board], exports.getCoordsAtIndex(index)))); };\nexports.getDiskAtIndex = getDiskAtIndex;\n/** Sets a single disk at the given coords */\nvar setDiskAtCoords = function (board, x, y, disk) {\n    board[y + 0] &= ~(1 << x);\n    board[y + 8] &= ~(1 << x);\n    if (disk === Disk.BLACK)\n        board[y + 0] |= 1 << x;\n    if (disk === Disk.WHITE)\n        board[y + 8] |= 1 << x;\n};\nexports.setDiskAtCoords = setDiskAtCoords;\n/** Sets a single disk at the given index */\nvar setDiskAtIndex = function (board, index, disk) { return (exports.setDiskAtCoords.apply(void 0, __spreadArrays([board], exports.getCoordsAtIndex(index), [disk]))); };\nexports.setDiskAtIndex = setDiskAtIndex;\n/** Is there a disk at the given coords? */\nvar hasDiskAtCoords = function (board, x, y) { return (exports.getDiskAtCoords(board, x, y) !== null); };\nexports.hasDiskAtCoords = hasDiskAtCoords;\n/** Is there a disk at the given index? */\nvar hasDiskAtIndex = function (board, index) { return (exports.getDiskAtCoords.apply(void 0, __spreadArrays([board], exports.getCoordsAtIndex(index))) !== null); };\nexports.hasDiskAtIndex = hasDiskAtIndex;\n/** Clear the entire board and place the four starting disks */\nvar initializeBoard = function (board) {\n    board.fill(0);\n    exports.setDiskAtCoords(board, 3, 3, Disk.WHITE); // White north west\n    exports.setDiskAtCoords(board, 4, 3, Disk.BLACK); // Black north east\n    exports.setDiskAtCoords(board, 3, 4, Disk.BLACK); // Black south west\n    exports.setDiskAtCoords(board, 4, 4, Disk.WHITE); // White south east\n};\nexports.initializeBoard = initializeBoard;\n/** Draw board as unicode string */\nvar toString = function (board, invert) {\n    if (invert === void 0) { invert = false; }\n    var diskBlack = invert ? '\\u25CB' : '\\u25CF';\n    var diskWhite = invert ? '\\u25CF' : '\\u25CB';\n    var result = '';\n    for (var y = 0; y < 8; y++) {\n        for (var x = 0; x < 8; x++) {\n            var disk = exports.getDiskAtCoords(board, x, y);\n            if (disk === Disk.BLACK) {\n                result += diskBlack;\n            }\n            else if (disk === Disk.WHITE) {\n                result += diskWhite;\n            }\n            else {\n                result += '\\xB7';\n            }\n        }\n        if (y < 7)\n            result += '\\n';\n    }\n    return result;\n};\nexports.toString = toString;\n/** Returns false if board is in an illegal state */\nvar isBoardLegal = function (board) {\n    for (var y = 0; y < 8; y++) {\n        if (board[y] & board[y + 8]) {\n            return false;\n        }\n    }\n    return true;\n};\nexports.isBoardLegal = isBoardLegal;\n/** Throws if board is in an illegal state */\nvar assertBoardLegal = function (board) {\n    if (!exports.isBoardLegal(board)) {\n        throw new Error('Board is in an illegal state');\n    }\n};\nexports.assertBoardLegal = assertBoardLegal;\n/** Returns true if every position on board is filled */\nvar isBoardFull = function (board) {\n    for (var y = 0; y < 8; y++) {\n        if (board[y] ^ board[y + 8] ^ 255) {\n            return false;\n        }\n    }\n    return true;\n};\nexports.isBoardFull = isBoardFull;\n/** Returns the coordinates in the given direction or null if on an edge */\nvar getNeighboringCoords = function (x, y, deltaX, deltaY) { return (x + deltaX < 0 ||\n    x + deltaX > 7 ||\n    y + deltaY < 0 ||\n    y + deltaY > 7 ?\n    null :\n    [x + deltaX, y + deltaY]); };\nexports.getNeighboringCoords = getNeighboringCoords;\n/** Type check input is not null */\nvar isNotNull = function (item) { return (item !== null); };\n/** Get coordinates for cells around all sides of given coords */\nvar getAllNeighboringCoords = function (x, y) { return [\n    exports.getNeighboringCoords(x, y, -1, -1),\n    exports.getNeighboringCoords(x, y, +0, -1),\n    exports.getNeighboringCoords(x, y, +1, -1),\n    exports.getNeighboringCoords(x, y, -1, +0),\n    exports.getNeighboringCoords(x, y, +1, +0),\n    exports.getNeighboringCoords(x, y, -1, +1),\n    exports.getNeighboringCoords(x, y, +0, +1),\n    exports.getNeighboringCoords(x, y, +1, +1),\n].filter(isNotNull); };\nexports.getAllNeighboringCoords = getAllNeighboringCoords;\n/** Get all valid coordinates in any direction from the given coords */\nvar getLine = function (x, y, deltaX, deltaY) {\n    var result = [];\n    var curX = x;\n    var curY = y;\n    while (true) {\n        var coords = exports.getNeighboringCoords(curX, curY, deltaX, deltaY);\n        if (!coords)\n            break;\n        result.push(coords);\n        curX += deltaX;\n        curY += deltaY;\n    }\n    return result;\n};\nexports.getLine = getLine;\n/** Get all lines in all directions from the given coords */\nvar getAllLines = function (x, y) { return [\n    exports.getLine(x, y, -1, -1),\n    exports.getLine(x, y, +0, -1),\n    exports.getLine(x, y, +1, -1),\n    exports.getLine(x, y, -1, +0),\n    exports.getLine(x, y, +1, +0),\n    exports.getLine(x, y, -1, +1),\n    exports.getLine(x, y, +0, +1),\n    exports.getLine(x, y, +1, +1),\n]; };\nexports.getAllLines = getAllLines;\n/** Get the opposing disk color */\nvar getOpponent = function (disk) { return (disk === Disk.BLACK ? Disk.WHITE : Disk.BLACK); };\nexports.getOpponent = getOpponent;\n/** Returns true if the postion at these coords can be played legally */\nvar isLegalMoveForCoords = function (board, x, y, disk) {\n    // Cannot play a disk in a position which already has a disk\n    if (exports.hasDiskAtCoords(board, x, y))\n        return false;\n    var lines = exports.getAllLines(x, y);\n    var opponent = exports.getOpponent(disk);\n    outer: for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {\n        var line = lines_1[_i];\n        // Must be at least two disks for a legal move\n        if (line.length < 2)\n            continue;\n        // First disk in line must be of the opposite color\n        if (exports.getDiskAtCoords(board, line[0][0], line[0][1]) !== opponent)\n            continue;\n        inner: for (var i = 1; i < line.length; i++) {\n            switch (exports.getDiskAtCoords(board, line[i][0], line[i][1])) {\n                // Valid move if there is a disk of our color in line\n                case disk: return true;\n                // Keep iterating over the their disks in this line\n                case opponent: continue inner;\n                // This move is not valid in this line if we hit an empty spot\n                default: continue outer;\n            }\n        }\n    }\n    // No valid moves found\n    return false;\n};\nexports.isLegalMoveForCoords = isLegalMoveForCoords;\n/** Returns true if the postion at this index can be played legally */\nvar isLegalMoveForIndex = function (board, index, disk) { return (exports.isLegalMoveForCoords.apply(void 0, __spreadArrays([board], exports.getCoordsAtIndex(index), [disk]))); };\nexports.isLegalMoveForIndex = isLegalMoveForIndex;\n/** Returns an array of all legal moves by index that the player can make */\nvar getLegalMoveIndexesForPlayer = function (board, disk) {\n    var moves = [];\n    for (var i = 0; i < exports.BOARD_TILES; i++) {\n        if (exports.isLegalMoveForIndex(board, i, disk)) {\n            moves.push(i);\n        }\n    }\n    return moves;\n};\nexports.getLegalMoveIndexesForPlayer = getLegalMoveIndexesForPlayer;\n/** Returns true if the player can make any moves at all */\nvar hasLegalMoves = function (board, disk) {\n    for (var i = 0; i < exports.BOARD_TILES; i++) {\n        if (exports.isLegalMoveForIndex(board, i, disk)) {\n            return true;\n        }\n    }\n    return false;\n};\nexports.hasLegalMoves = hasLegalMoves;\n/** Returns an array of all legal moves by coords that the player can make */\nvar getLegalMoveCoordsForPlayer = function (board, disk) {\n    var moves = [];\n    for (var y = 0; y < exports.BOARD_SIZE; y++) {\n        for (var x = 0; x < exports.BOARD_SIZE; x++) {\n            if (exports.isLegalMoveForIndex(board, x, disk)) {\n                moves.push([x, y]);\n            }\n        }\n    }\n    return moves;\n};\nexports.getLegalMoveCoordsForPlayer = getLegalMoveCoordsForPlayer;\n/** Returns a new board with the state of the board after this move is played */\nvar playMoveAtCoords = function (board, x, y, disk) {\n    var newBoard = exports.createBoard();\n    if (!exports.isLegalMoveForCoords(board, x, y, disk)) {\n        throw new Error('Move is illegal');\n    }\n    exports.setDiskAtCoords(newBoard, x, y, disk);\n    var lines = exports.getAllLines(x, y);\n    var opponent = exports.getOpponent(disk);\n    outer: for (var _i = 0, lines_2 = lines; _i < lines_2.length; _i++) {\n        var line = lines_2[_i];\n        // Must be at least two disks for a legal move\n        if (line.length < 2)\n            continue;\n        // First disk in line must be of the opposite color\n        if (exports.getDiskAtCoords(board, line[0][0], line[0][1]) !== opponent)\n            continue;\n        inner: for (var i = 1; i < line.length; i++) {\n            switch (exports.getDiskAtCoords(board, line[i][0], line[i][1])) {\n                // Valid move if there is a disk of our color in line\n                case disk: {\n                    for (var j = 0; j < i; j++) {\n                        exports.setDiskAtCoords(newBoard, line[j][0], line[j][1], disk);\n                    }\n                    continue outer;\n                }\n                // Keep iterating over the their disks in this line\n                case opponent: continue inner;\n                // This move is not valid in this line if we hit an empty spot\n                default: continue outer;\n            }\n        }\n    }\n    return newBoard;\n};\nexports.playMoveAtCoords = playMoveAtCoords;\n/** Returns a new board with the state of the board after this move is played */\nvar playMoveAtIndex = function (board, index, disk) { return (exports.playMoveAtCoords.apply(void 0, __spreadArrays([board], exports.getCoordsAtIndex(index), [disk]))); };\nexports.playMoveAtIndex = playMoveAtIndex;\n/** Takes a set of moves and applies them to a game board */\nvar applyMoves = function (board, moves) {\n    for (var y = 0; y < 8; y++) {\n        // Unset white moves from black positions\n        board[y + 0] &= ~moves[y + 8];\n        // Unset black moves from white positions\n        board[y + 8] &= ~moves[y + 0];\n        // Set black moves to black positions\n        board[y + 0] |= moves[y + 0];\n        // Set white moves to white positions\n        board[y + 8] |= moves[y + 8];\n    }\n};\nexports.applyMoves = applyMoves;\n/** Returns true if board is full or no more valid moves */\n// TODO: Add unit tests\nvar isGameOver = function (board) {\n    if (exports.isBoardFull(board))\n        return true;\n    for (var i = 0; i < exports.BOARD_TILES; i++) {\n        if (exports.isLegalMoveForIndex(board, i, Disk.BLACK) ||\n            exports.isLegalMoveForIndex(board, i, Disk.WHITE))\n            return false;\n    }\n    return true;\n};\nexports.isGameOver = isGameOver;\n/** Returns the number of set bits in an integer */\nvar countBits = function (value) {\n    var count = 0;\n    while (value > 0) {\n        if ((value & 1) === 1)\n            count++;\n        value >>= 1;\n    }\n    return count;\n};\n/** Get the number of disks of the given color on the board */\nvar getScore = function (board, disk) {\n    var offset = disk === Disk.BLACK ? 0 : 8;\n    var score = 0;\n    for (var i = 0; i < 8; i++) {\n        score += countBits(board[i + offset]);\n    }\n    return score;\n};\nexports.getScore = getScore;\n/** Return the color with the higher score or null if draw */\nvar getWinner = function (board) {\n    var scoreBlack = exports.getScore(board, Disk.BLACK);\n    var scoreWhite = exports.getScore(board, Disk.WHITE);\n    if (scoreBlack > scoreWhite)\n        return Disk.BLACK;\n    if (scoreWhite > scoreBlack)\n        return Disk.WHITE;\n    return null;\n};\nexports.getWinner = getWinner;\n/** Converts e.g. (5,4) to \"f5\" */\nvar getCardinalPositionFromCoords = function () {\n    var _a = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        _a[_i] = arguments[_i];\n    }\n    var x = _a[0], y = _a[1];\n    if (x < 0 || x > 7 || y < 0 || y > 7)\n        throw new Error('Position is out of bounds');\n    return String.fromCharCode(0x61 + x) + (y + 1);\n};\nexports.getCardinalPositionFromCoords = getCardinalPositionFromCoords;\n/** Converts e.g. 37 to \"f5\" */\nvar getCardinalPositionFromIndex = function (index) { return (exports.getCardinalPositionFromCoords.apply(void 0, exports.getCoordsAtIndex(index))); };\nexports.getCardinalPositionFromIndex = getCardinalPositionFromIndex;\n","import { MCTSBot } from 'boardgame.io/ai';\n// eslint-disable-next-line import/no-webpack-loader-syntax\nimport WorkerClass from 'workerize-loader!@othello/worker';\n\nconst worker = new WorkerClass();\n\nconst handleMessageOnce = <T = any>(messageType: string, handler: (payload?: T) => void) => {\n  const listener = ({ data }: { data: { type: string, payload: T } }) => {\n    if (!data || !data.type) return;\n    const { type, payload } = data;\n    if (messageType !== type) return;\n    handler(payload);\n    window.removeEventListener('message', listener);\n  };\n  worker.addEventListener('message', listener);\n};\n\nconst postMessage = <T = any>(type: string, payload?: T) => {\n  worker.postMessage({\n    type,\n    payload,\n  });\n};\n\nexport class WorkerBot extends MCTSBot {\n  constructor (...args: ConstructorParameters<typeof MCTSBot>) {\n    super(...args);\n    postMessage('INITIALIZE_BOT');\n  }\n\n  async play (...args: Parameters<MCTSBot['play']>) {\n    const promise = new Promise((resolve) => {\n      handleMessageOnce('PLAY_RESULT', resolve);\n    });\n    postMessage('PLAY', args);\n    return await promise as ReturnType<MCTSBot['play']>;\n  }\n}\n","import React from 'react';\nimport { Disk, getCoordsAtIndex } from '@othello/logic';\nimport classNames from 'classnames';\nimport { LogEntry } from 'boardgame.io';\nimport './DiskDisplay.css';\n\nexport interface Props {\n  disk: Disk;\n  index?: number;\n  log?: LogEntry[];\n}\n\nfunction usePrevious <T>(value: T): T | undefined {\n  const ref = React.useRef<T>();\n  React.useEffect(() => {\n    ref.current = value;\n  }, [value]);\n  return ref.current;\n}\n\nconst getLastMove = (log: LogEntry[]): LogEntry | undefined => {\n  for (let i = log.length - 1; i >= 0; i--) {\n    if (log[i].action.type === 'MAKE_MOVE') return log[i];\n  }\n}\n\nconst DISTANCE_DELAY = 50;\n\nconst DiskDisplay: React.FC<Props> = ({ disk, index, log, children }) => {\n  const previousDisk = usePrevious(disk);\n  const diskRef = React.createRef<HTMLDivElement>();\n  \n  React.useEffect(() => {\n    const diskElement = diskRef.current;\n    if (\n      index === undefined ||\n      log === undefined ||\n      previousDisk === undefined ||\n      previousDisk === disk ||\n      !diskElement\n    ) return;\n    const lastMove = getLastMove(log);\n    if (lastMove === undefined) return;\n    const [x, y] = getCoordsAtIndex(index);\n    const [lastX, lastY] = getCoordsAtIndex(lastMove.action.payload.args[0]);\n    const distance = Math.max(Math.abs(x - lastX), Math.abs(y - lastY));\n    const delay = distance * DISTANCE_DELAY;\n    diskElement.style.animationDelay = `${delay / 1000}s`;\n    diskElement.style.animationDuration = `0.5s`;\n    // diskElement.style.animationDelay = '0s';\n  }, [diskRef, disk, previousDisk, index, log]);\n\n  return (\n    <div ref={diskRef} className={classNames('DiskDisplay', {\n      'DiskDisplay--black': disk === Disk.BLACK,\n      'DiskDisplay--white': disk === Disk.WHITE,\n    })}>\n      {children}\n    </div>\n  );\n};\n\nexport default DiskDisplay;\n","import React from 'react';\nimport './MoveDisplay.css';\n\nexport interface Props {\n  onClick?: () => void;\n}\n\nconst MoveDisplay: React.FC<Props> = ({ onClick }) => (\n  <button\n    className=\"MoveDisplay\"\n    type=\"button\"\n    onClick={onClick}\n  />\n);\n\nexport default MoveDisplay;\n","import React from 'react';\nimport { BOARD_TILES, Disk, getDiskAtIndex, getScore, getWinner, isLegalMoveForIndex } from '@othello/logic';\nimport { G, getCurrentPlayer } from '@othello/game';\nimport { BoardProps } from 'boardgame.io/react';\nimport DiskDisplay from './DiskDisplay';\nimport MoveDisplay from './MoveDisplay';\nimport Log from './Log';\nimport './OthelloBoard.css';\n\nexport type Props = BoardProps<G>\n\nconst RENDER_LOG = false;\n\nconst OthelloBoard: React.FC<Props> = ({ G, ctx, moves, playerID, log }) => {\n  const showPositions = (\n    // Player ID must be specified\n    playerID != null &&\n    // It's our turn\n    ctx.currentPlayer === playerID\n  );\n  const playerDisk = getCurrentPlayer(ctx);\n  const winner = getWinner(G.board);\n  const mapToTile = (_: unknown, i: number) => {\n    const disk = getDiskAtIndex(G.board, i);\n    const canPlay = showPositions && isLegalMoveForIndex(G.board, i, playerDisk);\n    return (\n      <div className=\"OthelloBoard-tile\" key={`tile-${i}`}>\n        {disk !== null && (\n          <DiskDisplay disk={disk} key={`disk-${i}`} index={i} log={log}>\n            {G.lastPlaced === i && <span>{ctx.turn - 1}</span>}\n          </DiskDisplay>\n        )}\n        {canPlay && (\n          <MoveDisplay onClick={() => moves.clickCell(i)} />\n        )}\n      </div>\n    );\n  };\n  return (\n    <div className=\"OthelloBoard\">\n      <p><strong>Black:</strong> {getScore(G.board, Disk.BLACK)} <strong>White:</strong> {getScore(G.board, Disk.WHITE)}</p>\n      <div className=\"OthelloBoard-square\">\n        <div className=\"OthelloBoard-grid\">\n          {Array.from(new Array(BOARD_TILES), mapToTile)}\n        </div>\n      </div>\n      {ctx.gameover && <p><strong>{winner === null ? 'Draw' : winner === Disk.BLACK ? 'Black wins' : 'White wins'}</strong></p>}\n      {!ctx.gameover && <p>{ctx.currentPlayer === '0' ? 'Black\\'s turn' : 'White\\'s turn'}</p>}\n      {RENDER_LOG && (\n        <>\n          <p><strong>Log</strong></p>\n          <Log log={log} />\n        </>\n      )}\n    </div>\n  );\n};\n\nexport default OthelloBoard;\n","import React from 'react';\nimport { OthelloGame } from '@othello/game';\nimport { Local } from 'boardgame.io/multiplayer';\nimport { Client } from 'boardgame.io/react';\nimport { WorkerBot } from './worker-bot';\nimport OthelloBoard from './OthelloBoard';\nimport './App.css';\n\nconst OthelloClient = Client({\n  debug: false,\n  game: OthelloGame,\n  board: OthelloBoard,\n  multiplayer: Local({\n    bots: {\n      1: WorkerBot,\n    },\n  }),\n});\n\nconst App: React.FC = () => (\n  <div className=\"App\">\n    <OthelloClient playerID=\"0\" />\n  </div>\n);\n\nexport default App;\n","/** See https://css-tricks.com/the-trick-to-viewport-units-on-mobile/ */\nexport const updateVH = () => document.documentElement.style.setProperty('--vh', window.innerHeight * 0.01 + 'px');\n\nwindow.addEventListener('resize', updateVH);\n\nupdateVH();\n","import * as React from 'react';\nimport { render } from 'react-dom';\nimport App from './App';\nimport './update-vh';\nimport './styles.css';\n\nconst rootElement = document.getElementById(\"root\");\nrender(<App />, rootElement);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OthelloGame = exports.getCurrentPlayer = exports.diskToPlayer = exports.playerToDisk = void 0;\nvar logic_1 = require(\"@othello/logic\");\nvar playerToDisk = function (player) {\n    switch (player) {\n        case '0': return logic_1.Disk.BLACK;\n        case '1': return logic_1.Disk.WHITE;\n        default: throw new Error('Unexpected player ID: ' + player);\n    }\n};\nexports.playerToDisk = playerToDisk;\nvar diskToPlayer = function (disk) { return (String(disk)); };\nexports.diskToPlayer = diskToPlayer;\nvar getCurrentPlayer = function (ctx) { return (exports.playerToDisk(ctx.currentPlayer)); };\nexports.getCurrentPlayer = getCurrentPlayer;\nexports.OthelloGame = {\n    setup: function () {\n        var board = logic_1.createBoard();\n        logic_1.initializeBoard(board);\n        return {\n            board: board,\n            lastPlaced: null,\n        };\n    },\n    turn: {\n        moveLimit: 1,\n        order: {\n            first: function (_G, _ctx) { return 0; },\n            /**\n             * Called at the end of a player's turn.\n             * E.g. called after player 0 plays their first move and\n             * `ctx.playOrderPos` will be 0.\n             */\n            next: function (G, ctx) {\n                var currPos = ctx.playOrderPos;\n                var nextPos = (currPos + 1) % ctx.numPlayers;\n                var nextPlayer = ctx.playOrder[nextPos];\n                var nextDisk = exports.playerToDisk(nextPlayer);\n                return logic_1.hasLegalMoves(G.board, nextDisk) ? nextPos : currPos;\n            },\n        },\n    },\n    moves: {\n        clickCell: function (G, ctx, index) {\n            var board = G.board;\n            var disk = exports.getCurrentPlayer(ctx);\n            if (!logic_1.isLegalMoveForIndex(board, index, disk)) {\n                // TODO: Replace with `INVALID_MOVE` constant when not using Codesandbox\n                return 'INVALID_MOVE';\n            }\n            var clone = board.slice(0);\n            var moves = logic_1.playMoveAtIndex(clone, index, disk);\n            logic_1.applyMoves(clone, moves);\n            return {\n                board: clone,\n                lastPlaced: index,\n            };\n        },\n    },\n    endIf: function (G, _ctx) {\n        var board = G.board;\n        if (!logic_1.isGameOver(board))\n            return;\n        var winner = logic_1.getWinner(board);\n        if (winner === null)\n            return { draw: true };\n        return { winner: exports.diskToPlayer(winner) };\n    },\n    ai: {\n        enumerate: function (G, ctx) {\n            var board = G.board;\n            var disk = exports.getCurrentPlayer(ctx);\n            return logic_1.getLegalMoveIndexesForPlayer(board, disk)\n                .map(function (i) { return ({\n                move: 'clickCell',\n                args: [i],\n            }); });\n        },\n    },\n};\n","\n\t\t\t\tvar addMethods = require(\"../../../../node_modules/workerize-loader/dist/rpc-wrapper.js\")\n\t\t\t\tvar methods = []\n\t\t\t\tmodule.exports = function() {\n\t\t\t\t\tvar w = new Worker(__webpack_public_path__ + \"72a2024b332258685fb1.worker.js\", { name: \"[hash].worker.js\" })\n\t\t\t\t\taddMethods(w, methods)\n\t\t\t\t\t\n\t\t\t\t\treturn w\n\t\t\t\t}\n\t\t\t"],"sourceRoot":""}